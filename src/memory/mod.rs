// Memory module - stores agent context and history
// See docs/mem-design.md for design details

use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use std::collections::VecDeque;
use std::fs;
use std::path::PathBuf;
use thiserror::Error;
use tracing::{debug, info};
use uuid::Uuid;

/// Memory errors
#[derive(Debug, Error)]
pub enum MemoryError {
    #[error("Failed to load memory: {0}")]
    LoadFailed(String),

    #[error("Failed to store memory: {0}")]
    StoreFailed(String),

    #[error("Failed to generate embedding: {0}")]
    EmbeddingFailed(String),
}

/// Memory entry for semantic memory (new design)
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MemoryEntry {
    /// Unique identifier (UUID)
    pub id: String,
    /// Write timestamp
    pub timestamp: DateTime<Utc>,
    /// Interaction summary, generated by LLM
    pub content: String,
    /// Vector representation of content
    pub embedding: Vec<f32>,
}

impl MemoryEntry {
    /// Create a new memory entry
    pub fn new(content: String, embedding: Vec<f32>) -> Self {
        Self {
            id: Uuid::new_v4().to_string(),
            timestamp: Utc::now(),
            content,
            embedding,
        }
    }
}

/// Memory configuration
#[derive(Debug, Clone)]
pub struct MemoryConfig {
    /// Storage directory
    pub storage_dir: PathBuf,
    /// Number of entries to retrieve
    pub top_k: usize,
    /// Maximum cognition rounds
    pub max_cognition_rounds: usize,
    /// Embedding model identifier
    pub embedding_model: String,
}

impl Default for MemoryConfig {
    fn default() -> Self {
        Self {
            storage_dir: dirs::home_dir()
                .map(|p| p.join(".shelly").join("memory"))
                .unwrap_or_else(|| PathBuf::from(".shelly/memory")),
            top_k: 5,
            max_cognition_rounds: 3,
            embedding_model: "default".to_string(),
        }
    }
}

/// Journal entry types (old interface for backward compatibility)
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum JournalEntry {
    /// System information (hostname, OS, etc.)
    SystemInfo(String),
    /// User interaction record
    UserInteraction { query: String, response: String },
    /// Tool execution result
    ToolResult { tool: String, result: String },
    /// Agent's own observation
    Observation(String),
    /// Error or warning
    Error(String),
}

impl std::fmt::Display for JournalEntry {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            JournalEntry::SystemInfo(s) => write!(f, "[system] {}", s),
            JournalEntry::UserInteraction { query, response } => {
                write!(f, "[user] {} -> [response] {}", query, response)
            }
            JournalEntry::ToolResult { tool, result } => {
                write!(f, "[tool: {}] {}", tool, result)
            }
            JournalEntry::Observation(s) => write!(f, "[observation] {}", s),
            JournalEntry::Error(s) => write!(f, "[error] {}", s),
        }
    }
}

/// Maximum number of journal entries to keep
const MAX_JOURNAL_ENTRIES: usize = 100;

/// Memory - stores agent's semantic memory and journal
#[derive(Debug, Clone)]
pub struct Memory {
    /// Semantic memory entries (new design)
    entries: Vec<MemoryEntry>,
    /// Journal entries (old interface for backward compatibility)
    journal: VecDeque<JournalEntry>,
    /// Identity (static info about the agent)
    identity: String,
    /// Topology (known system structure)
    topology: Vec<String>,
    /// Configuration
    config: MemoryConfig,
}

impl Default for Memory {
    fn default() -> Self {
        Self {
            entries: Vec::new(),
            journal: VecDeque::new(),
            identity: String::new(),
            topology: Vec::new(),
            config: MemoryConfig::default(),
        }
    }
}

impl Memory {
    /// Create new empty memory with identity (backward compatible)
    pub fn new(identity: String) -> Self {
        Self {
            entries: Vec::new(),
            journal: VecDeque::new(),
            identity,
            topology: Vec::new(),
            config: MemoryConfig::default(),
        }
    }

    /// Load memory from disk (new design)
    pub fn load(config: MemoryConfig) -> Result<Self, MemoryError> {
        let entries_file = config.storage_dir.join("entries.json");

        if !entries_file.exists() {
            info!("Memory file not found, starting with empty memory");
            return Ok(Self {
                entries: Vec::new(),
                journal: VecDeque::new(),
                identity: String::new(),
                topology: Vec::new(),
                config,
            });
        }

        let content = fs::read_to_string(&entries_file)
            .map_err(|e| MemoryError::LoadFailed(e.to_string()))?;

        let entries: Vec<MemoryEntry> = serde_json::from_str(&content)
            .map_err(|e| MemoryError::LoadFailed(e.to_string()))?;

        info!("Loaded {} memory entries", entries.len());

        Ok(Self {
            entries,
            journal: VecDeque::new(),
            identity: String::new(),
            topology: Vec::new(),
            config,
        })
    }

    /// Store a memory entry (new design)
    pub async fn store(&mut self, entry: MemoryEntry) -> Result<(), MemoryError> {
        // Ensure directory exists
        if let Some(parent) = self.config.storage_dir.parent() {
            fs::create_dir_all(parent)
                .map_err(|e| MemoryError::StoreFailed(e.to_string()))?;
        }

        // Add entry
        self.entries.push(entry);

        // Persist to disk
        self.persist()?;

        Ok(())
    }

    /// Persist entries to disk
    fn persist(&self) -> Result<(), MemoryError> {
        let entries_file = self.config.storage_dir.join("entries.json");

        let content = serde_json::to_string_pretty(&self.entries)
            .map_err(|e| MemoryError::StoreFailed(e.to_string()))?;

        fs::write(&entries_file, content)
            .map_err(|e| MemoryError::StoreFailed(e.to_string()))?;

        debug!("Persisted {} memory entries", self.entries.len());

        Ok(())
    }

    /// Recall relevant memories by semantic similarity (new design)
    pub fn recall(&self, _query: &str, query_embedding: &[f32], top_k: usize) -> Vec<MemoryEntry> {
        if self.entries.is_empty() {
            return Vec::new();
        }

        // Calculate similarities
        let mut similarities: Vec<(usize, f32)> = self.entries
            .iter()
            .enumerate()
            .map(|(i, entry)| {
                let sim = cosine_similarity(query_embedding, &entry.embedding);
                (i, sim)
            })
            .collect();

        // Sort by similarity (descending)
        similarities.sort_by(|a, b| b.1.partial_cmp(&a.1).unwrap_or(std::cmp::Ordering::Equal));

        // Return top-k entries
        similarities
            .into_iter()
            .take(top_k)
            .map(|(i, _)| self.entries[i].clone())
            .collect()
    }

    /// Get all entries
    pub fn entries(&self) -> &[MemoryEntry] {
        &self.entries
    }

    /// Get configuration
    pub fn config(&self) -> &MemoryConfig {
        &self.config
    }

    /// Generate context string from recalled entries
    pub fn context_from_recall(&self, entries: &[MemoryEntry]) -> String {
        if entries.is_empty() {
            return String::new();
        }

        let mut parts = vec!["## Relevant Memory".to_string()];

        for entry in entries {
            let time_str = entry.timestamp.format("%Y-%m-%d %H:%M:%S").to_string();
            parts.push(format!("- [{}] {}", time_str, entry.content));
        }

        parts.join("\n")
    }

    // =====================
    // Backward compatible methods (old interface)
    // =====================

    /// Add entry to journal (backward compatible)
    pub fn add(&mut self, entry: JournalEntry) {
        self.journal.push_back(entry);
        // Trim if too large
        while self.journal.len() > MAX_JOURNAL_ENTRIES {
            self.journal.remove(0);
        }
    }

    /// Add system info
    pub fn add_system_info(&mut self, info: impl Into<String>) {
        self.add(JournalEntry::SystemInfo(info.into()));
    }

    /// Add user interaction
    pub fn add_interaction(&mut self, query: impl Into<String>, response: impl Into<String>) {
        self.add(JournalEntry::UserInteraction {
            query: query.into(),
            response: response.into(),
        });
    }

    /// Add tool result
    pub fn add_tool_result(&mut self, tool: impl Into<String>, result: impl Into<String>) {
        self.add(JournalEntry::ToolResult {
            tool: tool.into(),
            result: result.into(),
        });
    }

    /// Add observation
    pub fn add_observation(&mut self, observation: impl Into<String>) {
        self.add(JournalEntry::Observation(observation.into()));
    }

    /// Add error
    pub fn add_error(&mut self, error: impl Into<String>) {
        self.add(JournalEntry::Error(error.into()));
    }

    /// Add topology info
    pub fn add_topology(&mut self, info: impl Into<String>) {
        self.topology.push(info.into());
    }

    /// Generate context string for system prompt (backward compatible)
    pub fn context(&self) -> String {
        let mut parts = Vec::new();

        // Identity
        if !self.identity.is_empty() {
            parts.push(format!("## Identity\n{}", self.identity));
        }

        // Topology
        if !self.topology.is_empty() {
            parts.push(format!("## Known Topology\n{}", self.topology.join("\n")));
        }

        // Recent journal (last 10 entries)
        let recent: Vec<_> = self.journal.iter().rev().take(10).collect();
        if !recent.is_empty() {
            let journal_str = recent
                .iter()
                .rev()
                .map(|e| format!("- {}", e))
                .collect::<Vec<_>>()
                .join("\n");
            parts.push(format!("## Recent History\n{}", journal_str));
        }

        parts.join("\n\n")
    }

    /// Get full journal for debugging
    pub fn journal_entries(&self) -> Vec<&JournalEntry> {
        self.journal.iter().collect()
    }

    /// Set identity
    pub fn set_identity(&mut self, identity: impl Into<String>) {
        self.identity = identity.into();
    }
}

/// Calculate cosine similarity between two vectors
pub fn cosine_similarity(a: &[f32], b: &[f32]) -> f32 {
    if a.is_empty() || b.is_empty() {
        return 0.0;
    }

    let dot_product: f32 = a.iter().zip(b.iter()).map(|(x, y)| x * y).sum();
    let magnitude_a: f32 = a.iter().map(|x| x * x).sum::<f32>().sqrt();
    let magnitude_b: f32 = b.iter().map(|x| x * x).sum::<f32>().sqrt();

    if magnitude_a == 0.0 || magnitude_b == 0.0 {
        return 0.0;
    }

    dot_product / (magnitude_a * magnitude_b)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_cosine_similarity_identical() {
        let a = vec![1.0, 0.0, 0.0];
        let b = vec![1.0, 0.0, 0.0];
        assert!((cosine_similarity(&a, &b) - 1.0).abs() < 1e-6);
    }

    #[test]
    fn test_cosine_similarity_orthogonal() {
        let a = vec![1.0, 0.0, 0.0];
        let b = vec![0.0, 1.0, 0.0];
        assert!((cosine_similarity(&a, &b) - 0.0).abs() < 1e-6);
    }

    #[test]
    fn test_cosine_similarity_opposite() {
        let a = vec![1.0, 0.0, 0.0];
        let b = vec![-1.0, 0.0, 0.0];
        assert!((cosine_similarity(&a, &b) - (-1.0)).abs() < 1e-6);
    }

    #[test]
    fn test_cosine_similarity_zero_vector() {
        let a = vec![0.0, 0.0, 0.0];
        let b = vec![1.0, 0.0, 0.0];
        assert!((cosine_similarity(&a, &b) - 0.0).abs() < 1e-6);
    }

    #[test]
    fn test_memory_entry_creation() {
        let entry = MemoryEntry::new(
            "Test content".to_string(),
            vec![0.1, 0.2, 0.3],
        );
        assert!(!entry.id.is_empty());
        assert_eq!(entry.content, "Test content");
        assert_eq!(entry.embedding, vec![0.1, 0.2, 0.3]);
    }

    #[test]
    fn test_memory_empty_recall() {
        let memory = Memory::default();

        let results = memory.recall("query", &[0.1, 0.2, 0.3], 5);
        assert!(results.is_empty());
    }

    #[test]
    fn test_memory_context() {
        let mut memory = Memory::new("Shelly".to_string());
        memory.add_observation("Test observation");
        memory.add_tool_result("test_tool", "result");

        let ctx = memory.context();
        assert!(ctx.contains("Shelly"));
        assert!(ctx.contains("observation"));
    }

    #[test]
    fn test_memory_backward_compatible() {
        let mut memory = Memory::new("TestAgent".to_string());
        memory.add_system_info("hostname: test");
        memory.add_interaction("query", "response");
        memory.add_tool_result("tool", "output");
        memory.add_observation("note");
        memory.add_error("warning");
        memory.add_topology("network");

        let ctx = memory.context();
        assert!(ctx.contains("TestAgent"));
        assert!(ctx.contains("system"));
        assert!(ctx.contains("tool"));
        assert!(ctx.contains("network"));
    }
}
