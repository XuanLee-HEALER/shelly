// Memory types

use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use std::path::PathBuf;

/// Memory entry for semantic memory
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MemoryEntry {
    /// Unique identifier (UUID)
    pub id: String,
    /// Write timestamp
    pub timestamp: DateTime<Utc>,
    /// Interaction summary, generated by LLM
    pub content: String,
    /// Vector representation of content
    pub embedding: Vec<f32>,
}

impl MemoryEntry {
    /// Create a new memory entry
    pub fn new(content: String, embedding: Vec<f32>) -> Self {
        Self {
            id: uuid::Uuid::new_v4().to_string(),
            timestamp: Utc::now(),
            content,
            embedding,
        }
    }
}

/// Journal entry types (backward compatible interface)
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum JournalEntry {
    /// System information (hostname, OS, etc.)
    SystemInfo(String),
    /// User interaction record
    UserInteraction { query: String, response: String },
    /// Tool execution result
    ToolResult { tool: String, result: String },
    /// Agent's own observation
    Observation(String),
    /// Error or warning
    Error(String),
}

impl std::fmt::Display for JournalEntry {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            JournalEntry::SystemInfo(s) => write!(f, "[system] {}", s),
            JournalEntry::UserInteraction { query, response } => {
                write!(f, "[user] {} -> [response] {}", query, response)
            }
            JournalEntry::ToolResult { tool, result } => {
                write!(f, "[tool: {}] {}", tool, result)
            }
            JournalEntry::Observation(s) => write!(f, "[observation] {}", s),
            JournalEntry::Error(s) => write!(f, "[error] {}", s),
        }
    }
}
